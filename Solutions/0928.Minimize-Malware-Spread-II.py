928. Minimize Malware Spread II

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
Example 3:

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1



"""
the difference of this problem is when we remove a node from the list, 
that node cannot be infected anymore in later malware spread.
只需要在做bfs/dfs的时候保证next_candidate!=removed_node就可以了
solution 1: bfs 
"""
class Solution:
    def minMalwareSpread(self, matrix: List[List[int]], initial: List[int]) -> int:
        # step 1: change the adjacency matrix ot adjacency list
        graph = collections.defaultdict(set)    # 以后build adjacency matrix最好用set不要用list, 以这题为例，由于matrix是对称的，所以会导致有重复node，用set可以规避重复node
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if i != j and matrix[i][j] == 1:
                    graph[i].add(j)
                    graph[j].add(i)
                    
        initial.sort()      # sort the initial so that the smaller node will return first
        
        min_infected = float("inf")
        res = initial[0]
        for node in initial:
            infected = self._bfs(graph, node, initial)
            if infected < min_infected:
                min_infected = infected
                res = node
        return res
    
    def _bfs(self, graph, removed_node, initial):
        q = collections.deque()
        visited = set()
        for init_node in initial:
            if init_node == removed_node:
                continue
            q.append(init_node)
            visited.add(init_node)

        while q:
            curr_node = q.popleft()
            for next_node in graph[curr_node]:
                if next_node == removed_node:
                    continue
                if next_node in visited:    # when we remove a node from the list, 
                    continue                # that node cannot be infected anymore in later malware spread
                q.append(next_node)
                visited.add(next_node)

        return len(visited)
        
        
        
"""
solution 2: dfs - O(M^2N^2)
"""
class Solution:
    def minMalwareSpread(self, matrix: List[List[int]], initial: List[int]) -> int:
        # step 1: build adjancency dicionary
        graph = collections.defaultdict(list)
        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix[0])):   # 只需要遍历一半，不然会有很多重复的node在graph中
                if matrix[i][j] == 1:
                    graph[i].append(j)
                    graph[j].append(i)
                    
        initial.sort()      # sort the initial so that the smaller node will return first
        
        min_infected = len(graph)
        res = initial[0]
        for removed_node in initial:
            # 以每一个节点n开始做dfs
            visited = set()
            for node in initial:
                if node != removed_node and node not in visited:
                    self._dfs(node, removed_node, graph, visited)
                   
            # 做完dfs之后判断多少个infected
            infected_cnt = len(visited)
            if infected_cnt < min_infected:
                min_infected = infected_cnt
                res = removed_node
        return res
                
    def _dfs(self, curr_node, removed_node, graph, visited):
        visited.add(curr_node)
        for next_node in graph[curr_node]:
            if next_node == removed_node:   # 注意这是题眼: when we remove a node from the list, 
                continue                    # that node cannot be infected anymore in later malware spread
            if next_node not in visited:
                self._dfs(next_node, removed_node, graph, visited)
