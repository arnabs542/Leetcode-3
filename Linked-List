做Linked List的题目一定要懂reference/pointer，Linked List都是处理指针的问题。
node = ListNode(1) 操作表示新建一个node，这个node其实是一个reference/pointer
一个Linked List Node：ListNode(1)在内存地址中占用8个字节的位置，其中的4个字节存储了一个数字也就是node.val; 另外4个字节存储了一个指针也就是node.next，这个指针的值是下一个Linked List Node在内存中的存储位置。
所以node.val和node.next是存在物理内存中的，而node本身只是一个局部变量，并不存在物理内存中。
所以如果我们去修改局部变量的话（如操作 node = someNode）, 根本不会改变原来node原来的连接关系。

我们来解析一下下面的操作：
Node1 = LinkedListNode(1)
Node2 = LinkedListNode(2)
Node1.next = Node2
Head = Node1
Node1 = Node2

定义Node1 = LinkedListNode(1)的意思是定义一个局部变量Node1，这个局部变量Node1本质是一个reference/pointer，指向数字1的物理地址，这个物理地址中保存了数字1，占用4个字节，同时这个数字1右边的4个字节的地方也被占用，虽然那四个字节暂时存储的是None。
同理Node2 = LinkedListNode(2) 也是类似的意思。
接下来Node1.next = Node2 的意思是把刚刚在数字1旁边暂时存储None的那4个字节的物理空间放入一个pointer，这个pointer的值是LinkedListNode(2)的数值2的物理地址（所以也叫pointer指向LinkedListNode(2)）。得到的链表结构如下：

LinkedListNode(1)  LinkedListNode(2)
  -------------      -------------  
  |  1  |  ---|--->  |  2  |   --|--->  None
  -------------      -------------
     ^                ^
     |                |
   Node1          Node2

接下来定义Head = Node1的意思是定义一个局部变量Head指向Node1相同的物理地址，得到的链表结构如下：

LinkedListNode(1)  LinkedListNode(2)
  -------------      -------------  
  |  1  |  ---|--->  |  2  |   --|--->  None
  -------------      -------------
   ^  ^                ^
   |  |                |
 Head Node1          Node2

接下来操作 Node1 = Node2 做的事情是让Node1这个局部变量指向Node2这个局部变量所指向的物理地址（LinkedListNode(2)的数值存放的那个物理地址），而不再原来指向的那个地址（LinkedListNode(1)的数值存放的那个物理地址）。得到的链表结构如下：

LinkedListNode(1)  LinkedListNode(2)
  -------------      -------------  
  |  1  |  ---|--->  |  2  |   --|--->  None
  -------------      -------------
   ^                  ^   ^
   |                  |   |
 Head              Node1  Node2
 
我们看到，这时候Head还是指向LinkedListNode(1)的数值存放的那个物理地址，并没有因为Node1 = Node2的操作而发生改变，而且整个链表的结构也没有任何改变。
只有操作someNode.val = ..., someNode.next = ....才会让链表发生变化。
someNode.val = someValue 是改变someNode的前四个字节里存放值为someValue
someNode.next = someNode 是改变someNode的后四个字节里存放的值为someNode（也就是改成了someNode的存放地址）


做链表的复杂的问题，我们可以先想出大体的思路，然后再一个一个实现.
复杂的题目可以先建一个dummy node来保存头部不动，模板如下：
dummy = ListNode(0)
dummy.next = head 
curr = dummy or curr = dummy.next
...中间程序(可能head会发生变化)...
return dummy.next

做题的过程做可以多开几个局部变量，这样代码会好读懂一些，像24. Swap Nodes in Pairs 那样，画出图来就知道reverse要干什么，connect要干什么了。



 
 
 
 
 
 
 
 
 
 
 
