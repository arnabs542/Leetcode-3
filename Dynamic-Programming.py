动态规划一般用来求最优解或者求有多少解，而打印出所有的解是动态规划做不了的，必须用递归或DFS来做。

动态规划题目的特点：
1.  计数
       - 有多少种方式走到右下角 
       - 有多少种方法选出k个数使得和是Sum
eg: 62. Unique Paths
       
2.  求最大最小值！  （扣题目字眼，如find maximum sum, minimum cost, maximum length等）, 求极值的题目，不是Greedy就是DP啊，一般难题偏DP的比较多。
       - 从左上角走到右下角路径的最大数字和
       - 最长上升子序列长度
eg: 322. Coin Change; 120. Triangle; 152. Maximum Product Subarray
       
3.  求存在性
       - 取石子游戏，先手是否必胜
       - 能不能选出k个数使得和是Sum
eg: 55. Jump Game
       

动态规划四个组成部分：
1. 确定状态
• 研究最优策略的最后一步
• 化为子问题
2. 转移方程
• 根据子问题定义直接得到
3. 初始条件和边界情况
• 细心，考虑周全
4. 计算顺序
• 利用之前的计算结果
       
    
第一讲：坐标型动态规划: 62. Unique Paths； 63. Unique Path II； 64. Minimum Path Sum
题目特点：
给定一个序列或网格，需要找到序列中的子序列/网格中的某条路径的
- 最大值/最小值
- 计数
- 存在性
这类题目的状态通常定义为：                           
f(i)表示以(i)结尾的子序列的最大值/最小值或者计数或者存在性；初始条件为f(0) 
f(i,j)表示以(i,j)结尾的路径最大值/最小值或者计数或者存在性；初始条件为f(0,0)或者f(i,0)或者f(0,j)                                                       
                              
第二讲：序列型动态规划 
256. Paint House
f(i)表示以(i)结尾的子序列的某种性质如最大值/最小值或者计数或者存在性；初始条件为f(0)
分支：最长序列型 300. Longest Increasing Subsequence

第二讲：位操作型动态规划 
338. Counting Bits
知识点：和位操作相关的动态规划一般用值作为状态

第三讲：划分型动态规划 
91. Decode Ways
状态往往定义为前j个的某种特性，不包括j！！！！，这个思想很重要，相当于给前面做了一层buffer layer
eg 132: f[j]=the minimum number of total palindrom a palindrome partitining before the jth character (meaning the last palindrome should end with the j-1th character)
f[j]=min(f[i]+1) for i<j and s[i:j] is palindrome
                                                     
第三讲：博弈型动态规划 
博弈型动态规划通常从第一部开始分析，而不是最后一步。
先手出招后，新的先手面对一个新的局面，所以永远只care先手就可以了。所以f[i]=先手面对的情况必胜
        
第四讲：背包型动态规划 
背包问题一定要把总重量放入状态！！！很重要！！
f[i][m]=能否用前i个物品(不包括i)拼出重量m，或者f[i][m]=用前i个物品(不包括i)拼出重量m有多少种方式。
如果问题要求用i个数加在一起拼出target，那么多半是背包问题。
背包问题的关键点是最后一步！
                              
第五讲：区间型动态规划 
给定一些序列/字符串，进行一些操作，求满足区间[i, j]的一些性质的题目
自然而然将状态定义为f[i][j]表示面对子序列[i, j]时的最佳性质。

第六讲：双序列型动态规划 
顾名思义，有两个数组/字符串，需要进行一些操作
每个序列本身是一维的，可以转换为二维数组。
二维数组下标表示序列A前i个，序列B前j个: f[i][j]
一定要用一个buffer layer！！！初始条件就是处理空串！
初始条件和边界情况
– 空串如何处理
– 计数型(情况1+情况2+…)以及最值型(min/max{情况1，情况2，…})
eg: 1143 LCS 问题，遇到序列型问题，注意前面有一层buffer layer很重要


       
动态规划组成部分（以322.Coin Change为例）
1.1. 确定状态
• 状态在动态规划中的作用属于定海神针。简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
确定状态需要两个意识：
– 最后一步
– 子问题

1.2. 最后一步
• 虽然我们不知道最优策略是什么，但是最优策略肯定是K枚硬币a1, a2,…, aK 面值加起来是27
• 所以一定有一枚最后的硬币: aK
• 除掉这枚硬币，前面硬币的面值加起来是27 - aK
关键点1: 我们不关心前面的K-1枚硬币是怎么拼出27- aK的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道aK和K，但是我们确定前面的硬币拼出了27 - aK 
关键点2: 因为是最优策略，所以拼出27 - aK 的硬币数一定要最少，否则这就不是最优策略了

1.3. 子问题
• 所以我们就要求：最少用多少枚硬币可以拼出27 - aK
• 原问题是最少用多少枚硬币拼出27
• 我们将原问题转化成了一个子问题，而且规模更小：27 - aK
• 为了简化定义，我们设状态f(X)=最少用多少枚硬币拼出X

• 等等，我们还不知道最后那枚硬币aK是多少
• 最后那枚硬币aK只可能是2，5或者7
• 如果aK是2，f(27)应该是f(27-2) + 1 (加上最后这一枚硬币2）
• 如果aK是5，f(27)应该是f(27-5) + 1 (加上最后这一枚硬币5）
• 如果aK是7，f(27)应该是f(27-7) + 1 (加上最后这一枚硬币7）
• 除此以外，没有其他的可能了
• 需要求最少的硬币数，所以：f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}

递归解法的问题
• 做了很多重复计算，效率低下，指数级别
• 如何避免？
• 将计算结果保存下来，并改变计算顺序

2. 转移方程
• 设状态f[X]=最少用多少枚硬币拼出X
• 对于任意X, f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}

3. 初始条件和边界情况（初始条件是转移方程算不出来的；边界条件是不要数组越界）
• f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}
• 两个问题：X-2, X-5 或者X-7小于0怎么办？什么时候停下来？
• 如果不能拼出Y，就定义f[Y]=正无穷
– 例如f[-1]=f[-2]=…=正无穷
• 所以f[1] =min{f[-1]+1, f[-4]+1,f[-6]+1}=正无穷, 表示拼不出来1
• 初始条件：f[0] = 0

4. 计算顺序（确定方法：想要算f[x]的时候右边用过的状态都已经算过了）
• 拼出 X 所需要的最少硬币数： f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}
• 初始条件：f[0] = 0
• 然后计算f[1], f[2], …, f[27]
• 当我们计算到f[X]时，f[X-2], f[X-5], f[X-7]都已经得到结果了

算法复杂度：
• 每一步尝试三种硬币，一共27步
• 与递归算法相比，没有任何重复计算
• 算法时间复杂度（即需要进行的步数）： 27 * 3





