https://www.cnblogs.com/chaoguo1234/p/9246791.html

Python决定一个变量时局部的，还是全局的，是在编译期
Python中的变量名是在编译时就解析好的，换句话说，在编译时(也就是在交互控制台输入代码是或者import文件时)，Python就已经决定一个变量应该是局部变量，还是全局变量。来看下面的例子：


>>>X = 99
>>>def test():
    print(X)


>>>test()
99

函数test里面引用的变量，根据作用域链查找法则(LEGB法则)，查找到的是全局变量X的值。

 


>>>X = 99
>>>def test():
    print(X)
    X = 88


>>>test()
UnboundLocalError:local variable 'X' referenced before assignment  # 报错

根据文章开头所说，Python决定一个变量时局部的，还是全局的，是在编译期，当编译到函数test时，看到了X = 88的赋值语句，因此，Python认为X在函数test里面应该是一个局部变量，所以，当test函数运行时，执行print(X)语句，发现局部变量X未赋值就被引用了，所以报错了。

事实上，在函数体内进行的任何赋值操作，包括=，import，嵌套的def定义，嵌套的class定义，等等，都会产生局部变量。在Python函数内部，局部变量和全局变量是无法共存的，只能存在一种：


>>>X = 99
>>>def test():
    X = 88
    global X

>>>test()
>>>X                         # 输出的是88
88
复制代码
在上面的例子中，Python在编译函数test的时，首先看到赋值语句X = 88，认定X应该是局部变量，但是，当继续往下时，发现了global X语句，这将X声明成了一个局部变量，因此，Python最终将test函数内部的X变量认定成一个全局变量，并最终运行时，改变了全局变量X的的值，最后打印的结果为88。

需要注意的是，如果global的声明晚于变量的使用，Python会产生警告：SyntaxWarning:name 'X' is assign to before global declaration
